# P2P Application Suite with Load Balancing

A distributed peer-to-peer application suite featuring clients, indexers, curators, and a load balancer to manage high traffic loads.

## Components

- **Client**: User-facing component that makes requests to the indexers
- **Indexer**: Manages indices as key-value pairs, supporting operations to add, remove, and query items
- **Curator**: Maintains curated content with title-content mappings
- **Load Balancer**: Distributes client requests across multiple indexers based on load metrics

## How to Run

```bash
# After making changes to any component, regenerate the bindings
hyper-bindgen

# Build all components
kit b

# Run tests
kit run-tests

# Start with fake node
kit f
kit bs
```

## Key Features

- **Load Balancing**: Prevents indexers from being overloaded during high traffic
- **Health Monitoring**: Automatic health checks ensure only healthy indexers receive traffic
- **Fault Tolerance**: Clients can fall back to direct indexer access if load balancer is unavailable
- **Multiple Distribution Strategies**: Supports least connections, round robin, and random selection
- **Stateful Components**: All components maintain state that is persisted based on configurable strategies

## Architecture

The system uses a WebAssembly-based process framework with:
- RPC-style communication between components
- Async support through a custom runtime
- Serialized message passing
- Built-in state persistence

## Usage

See individual component READMEs for detailed usage:
- [Load Balancer](./load-balancer/README.md)

## Todos for the Future

- Http stubs aren't fully generated yet. Using hyperware process lib to send_request (POST) should be fairly straightforward. Extending [hyper-bindgens](https://github.com/hyperware-ai/hyper-bindgen) caller util generator with an example of how a client request works should be able to one shot it. This will allows using autogenerated rpc functions for rpc calls.
- Add support for `LazyLoadBlob` in a message body. This will allow sending larger messages within this framework.
- Autogenerate function stubs from wit files in js/ts for frontend work. This is the exact same as how caller-utils is generated, except for js/ts. This will allow your frontend code to call hyperware processes as if they were just functions.
- Add better logging for tests. `print_to_terminal` only works on failure, and logging could be very useful here to understand what is generally going on.
- Occasionally, even when having made changes to the code, `kit b` or `kit run-tests` doesn't trigger compilation, and one has to edit the files once more. This could cause problems during development with LLMs and is likely a `kit` issue.
- We currently use `record`s in the `wit` files to represent function signatures. It is entirely possible to change these to regular functions that return a future. Future support for implementing a wit component will only be available with WASI preview 3, but one can change the stub generation code to already accomodate this. Procrastinating on this one until preview 3 is probably fine.
- Heavy dogfooding and performance tests.
- Test websocket client from a frontend.
- Add more load balancing strategies and make them configurable at runtime
- Implement load balancer high availability through a cluster setup
- Add geographic routing support for distributed deployments
