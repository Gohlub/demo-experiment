use hyperprocess_macro::hyperprocess;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use hyperware_app_common::SendResult;

// Import the load balancer utilities that will be generated by hyper-bindgen
use caller_utils::load_balancer::{
    register_indexer_remote_rpc
};

#[derive(Default, Debug, Serialize, Deserialize)]
struct IndexerState {
    indices: HashMap<String, Vec<String>>, // Maps index name to list of items
    request_count: u64,
    last_report_count: u64,
    max_capacity: u32,
    registered_with_lb: bool,
    load_balancer_address: Option<String>,
}

#[hyperprocess(
    name = "Indexer",
    ui = Some(HttpBindingConfig::default()),
    endpoints = vec![
        Binding::Http {
            path: "/api",
            config: HttpBindingConfig::new(false, false, false, None),
        }, 
        Binding::Ws {
            path: "/ws",
            config: WsBindingConfig::new(false, false, false),
        }
    ],
    save_config = SaveOptions::EveryMessage,
    wit_world = "app-framework-demo-uncentered-dot-os-v0"
)]
impl IndexerState {
    #[init]
    async fn initialize(&mut self) {
        println!("Indexer initializing");
        
        // Initialize with empty hashmap if not already present
        if self.indices.is_empty() {
            self.indices = HashMap::new();
        }
        
        // Set default capacity - this could be configurable
        self.max_capacity = 1000;
        
        // Try to register with load balancer if address is configured
        if let Some(lb_addr) = &self.load_balancer_address {
            self.register_with_load_balancer(lb_addr.clone()).await;
        } else {
            println!("No load balancer configured, running independently");
        }
        
        // Set up periodic load reporting
        let _my_address = std::env::var("PROCESS_ADDRESS").unwrap_or_else(|_| "indexer:app:sys".to_string());
            
        let lb_address = self.load_balancer_address.clone();
        
        if let Some(_lb_addr) = lb_address {
            let _capacity = self.max_capacity;
            
            // Start a background task to report load periodically
            let interval = std::time::Duration::from_secs(10);
            std::thread::spawn(move || {
                loop {
                    println!("Reporting load to load balancer");
                    // Implementation to be added when needed
                    std::thread::sleep(interval);
                }
            });
        }
    }
    
    // Register this indexer with the load balancer
    async fn register_with_load_balancer(&mut self, lb_address: String) -> bool {
        println!("Registering with load balancer at {}", lb_address);
        
        // Get this process's address or use a placeholder for testing
        let my_address = std::env::var("PROCESS_ADDRESS").unwrap_or_else(|_| "indexer:app:sys".to_string());
        
        use hyperware_process_lib::Address;
        use std::str::FromStr;
        
        // Parse the address string
        let lb_addr = match Address::from_str(&lb_address) {
            Ok(addr) => addr,
            Err(e) => {
                println!("Failed to parse address: {:?}", e);
                return false;
            }
        };
        
        match register_indexer_remote_rpc(&lb_addr, my_address, self.max_capacity).await {
            SendResult::Success(true) => {
                println!("Successfully registered with load balancer");
                self.registered_with_lb = true;
                self.load_balancer_address = Some(lb_address);
                return true;
            },
            _ => {
                println!("Failed to register with load balancer");
            }
        }
        
        false
    }
    
    // Method to set the load balancer address and register with it
    #[remote]
    #[local]
    async fn set_load_balancer(&mut self, lb_address: String) -> bool {
        // Store the load balancer address
        self.load_balancer_address = Some(lb_address.clone());
        
        // Try to register with the load balancer
        self.register_with_load_balancer(lb_address).await
    }
    
    // Method to get current load information
    #[remote]
    #[local]
    fn get_load_info(&mut self) -> IndexerLoadInfo {
        IndexerLoadInfo {
            request_count: self.request_count,
            index_count: self.indices.len() as u32,
            total_items: self.indices.values().map(|v| v.len()).sum::<usize>() as u32,
            max_capacity: self.max_capacity,
        }
    }
    
    #[remote]
    async fn add_to_index(&mut self, index_name: String, item: String) -> bool {
        // Track request for load balancing
        self.request_count += 1;
        
        let items = self.indices.entry(index_name).or_insert_with(Vec::new);
        if !items.contains(&item) {
            items.push(item);
            true
        } else {
            false // Item already exists in the index
        }
    }

    #[remote]
    async fn remove_from_index(&mut self, index_name: String, item: String) -> bool {
        // Track request for load balancing
        self.request_count += 1;
        
        if let Some(items) = self.indices.get_mut(&index_name) {
            let original_len = items.len();
            items.retain(|i| i != &item);
            original_len != items.len() // Returns true if an item was removed
        } else {
            false // Index doesn't exist
        }
    }

    #[remote]
    async fn get_index(&mut self, index_name: String) -> Option<Vec<String>> {
        // Track request for load balancing
        self.request_count += 1;
        
        self.indices.get(&index_name).cloned()
    }

    #[remote]
    async fn list_indices(&mut self) -> Vec<String> {
        // Track request for load balancing
        self.request_count += 1;
        
        self.indices.keys().cloned().collect()
    }
}

// Structure for reporting load information
#[derive(Serialize, Deserialize, Debug)]
struct IndexerLoadInfo {
    request_count: u64,
    index_count: u32,
    total_items: u32,
    max_capacity: u32,
}

