use hyperprocess_macro::hyperprocess;
use serde::{Deserialize, Serialize};
pub use hyperware_app_common::SendResult;
use hyperware_process_lib::Address;
use std::str::FromStr;
// Import functions from caller-utils that will be generated by hyper-bindgen
use caller_utils::load_balancer::get_available_indexer_remote_rpc;
use caller_utils::indexer::{
    add_to_index_remote_rpc, 
    remove_from_index_remote_rpc, 
    get_index_remote_rpc, 
    list_indices_remote_rpc
};

#[derive(Default, Debug, Serialize, Deserialize)]
struct ClientState {
    load_balancer_address: Option<String>,
    direct_indexer_address: Option<String>,
    use_load_balancer: bool,
    request_count: u64,
    success_count: u64,
    failure_count: u64,
}

#[hyperprocess(
    name = "Client",
    ui = Some(HttpBindingConfig::default()),
    endpoints = vec![
        Binding::Http {
            path: "/api",
            config: HttpBindingConfig::new(false, false, false, None),
        }, 
        Binding::Ws {
            path: "/ws",
            config: WsBindingConfig::new(false, false, false),
        }
    ],
    save_config = SaveOptions::EveryMessage,
    wit_world = "app-framework-demo-uncentered-dot-os-v0"
)]
impl ClientState {
    #[init]
    async fn initialize(&mut self) {
        println!("Initializing client");    
        
        // By default, use load balancer if configured
        self.use_load_balancer = self.load_balancer_address.is_some();
        
        if self.use_load_balancer {
            println!("Client will use load balancer for indexer access");
        } else if let Some(idx) = &self.direct_indexer_address {
            println!("Client will use direct indexer access at {}", idx.to_string());
        } else {
            println!("No indexer access configured");
        }
    }

    // Configure the client to use a load balancer
    #[remote]
    #[local]
    async fn set_load_balancer(&mut self, lb_address: String) -> bool {
        self.load_balancer_address = Some(lb_address);
        self.use_load_balancer = true;
        true
    }
    
    // Configure the client to use a direct indexer
    #[remote]
    #[local]
    async fn set_direct_indexer(&mut self, indexer_address: String) -> bool {
        self.direct_indexer_address = Some(indexer_address);
        self.use_load_balancer = false;
        true
    }
    
    // Toggle between load balancer and direct indexer
    #[remote]
    #[local]
    async fn toggle_load_balancer_usage(&mut self) -> bool {
        if self.load_balancer_address.is_none() && self.use_load_balancer {
            // Can't enable load balancer if not configured
            return false;
        }
        
        self.use_load_balancer = !self.use_load_balancer;
        println!("Load balancer usage set to: {}", self.use_load_balancer);
        true
    }
    
    // Get stats about the client
    #[remote]
    #[local]
    async fn get_stats(&self) -> ClientStats {
        ClientStats {
            total_requests: self.request_count,
            successful_requests: self.success_count,
            failed_requests: self.failure_count,
            using_load_balancer: self.use_load_balancer,
        }
    }

    // Original methods
    #[remote]
    #[local]
    async fn leet(&self, test: u32) -> u32 {
        1337 * test
    }

    #[remote]
    async fn just_leet(&self) -> u32 {
        1337
    }
    
    // Enhanced indexer methods that use load balancing
    
    // Add an item to an index with load balancing
    #[remote]
    #[local]
    async fn lb_add_to_index(&mut self, index_name: String, item: String) -> IndexResult {
        self.request_count += 1;
        
        let target_indexer = self.get_indexer_address().await;
        
        match target_indexer {
            Some(indexer_addr_str) => {
                let indexer_addr = match Address::from_str(&indexer_addr_str) {
                    Ok(addr) => addr,
                    Err(_) => return IndexResult {
                        success: false,
                        result_value: None,
                        error: Some("Invalid indexer address format".to_string()),
                    }
                };
                
                match add_to_index_remote_rpc(&indexer_addr, index_name, item).await {
                    SendResult::Success(result) => {
                        self.success_count += 1;
                        IndexResult {
                            success: true,
                            result_value: Some(vec![result.to_string()]),
                            error: None,
                        }
                    },
                    SendResult::Timeout => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some("Request timed out".to_string()),
                        }
                    },
                    SendResult::Offline => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some("Indexer is offline".to_string()),
                        }
                    },
                    SendResult::DeserializationError(e) => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some(format!("Deserialization error: {}", e)),
                        }
                    }
                }
            },
            None => {
                self.failure_count += 1;
                IndexResult {
                    success: false,
                    result_value: None,
                    error: Some("No indexer available".to_string()),
                }
            }
        }
    }
    
    // Remove an item from an index with load balancing
    #[remote]
    #[local]
    async fn lb_remove_from_index(&mut self, index_name: String, item: String) -> IndexResult {
        self.request_count += 1;
        let target_indexer = self.get_indexer_address().await;
        
        match target_indexer {
            Some(indexer_addr_str) => {
                let indexer_addr = match Address::from_str(&indexer_addr_str) {
                    Ok(addr) => addr,
                    Err(_) => return IndexResult {
                        success: false,
                        result_value: None,
                        error: Some("Invalid indexer address format".to_string()),
                    }
                };
                
                match remove_from_index_remote_rpc(&indexer_addr, index_name, item).await {
                    SendResult::Success(result) => {
                        self.success_count += 1;
                        IndexResult {
                            success: true,
                            result_value: Some(vec![result.to_string()]),
                            error: None,
                        }
                    },
                    SendResult::Timeout => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some("Request timed out".to_string()),
                        }
                    },
                    SendResult::Offline => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some("Indexer is offline".to_string()),
                        }
                    },
                    SendResult::DeserializationError(e) => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some(format!("Deserialization error: {}", e)),
                        }
                    }
                }
            },
            None => {
                self.failure_count += 1;
                IndexResult {
                    success: false,
                    result_value: None,
                    error: Some("No indexer available".to_string()),
                }
            }
        }
    }
    
    // Get an index with load balancing
    #[remote]
    #[local]
    async fn lb_get_index(&mut self, index_name: String) -> IndexResult {
        self.request_count += 1;
        
        let target_indexer = self.get_indexer_address().await;
        
        match target_indexer {
            Some(indexer_addr_str) => {
                let indexer_addr = match Address::from_str(&indexer_addr_str) {
                    Ok(addr) => addr,
                    Err(_) => return IndexResult {
                        success: false,
                        result_value: None,
                        error: Some("Invalid indexer address format".to_string()),
                    }
                };
                
                match get_index_remote_rpc(&indexer_addr, index_name).await {
                    SendResult::Success(result) => {
                        self.success_count += 1;
                        IndexResult {
                            success: true,
                            result_value: result,
                            error: None,
                        }
                    },
                    SendResult::Timeout => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some("Request timed out".to_string()),
                        }
                    },
                    SendResult::Offline => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some("Indexer is offline".to_string()),
                        }
                    },
                    SendResult::DeserializationError(e) => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some(format!("Deserialization error: {}", e)),
                        }
                    }
                }
            },
            None => {
                self.failure_count += 1;
                IndexResult {
                    success: false,
                    result_value: None,
                    error: Some("No indexer available".to_string()),
                }
            }
        }
    }
    
    // List all indices with load balancing
    #[remote]
    #[local]
    async fn lb_list_indices(&mut self) -> IndexResult {
        self.request_count += 1;
        
        let target_indexer = self.get_indexer_address().await;
        
        match target_indexer {
            Some(indexer_addr_str) => {
                let indexer_addr = match Address::from_str(&indexer_addr_str) {
                    Ok(addr) => addr,
                    Err(_) => return IndexResult {
                        success: false,
                        result_value: None,
                        error: Some("Invalid indexer address format".to_string()),
                    }
                };
                
                match list_indices_remote_rpc(&indexer_addr).await {
                    SendResult::Success(result) => {
                        self.success_count += 1;
                        IndexResult {
                            success: true,
                            result_value: Some(result),
                            error: None,
                        }
                    },
                    SendResult::Timeout => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some("Request timed out".to_string()),
                        }
                    },
                    SendResult::Offline => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some("Indexer is offline".to_string()),
                        }
                    },
                    SendResult::DeserializationError(e) => {
                        self.failure_count += 1;
                        IndexResult {
                            success: false,
                            result_value: None,
                            error: Some(format!("Deserialization error: {}", e)),
                        }
                    }
                }
            },
            None => {
                self.failure_count += 1;
                IndexResult {
                    success: false,
                    result_value: None,
                    error: Some("No indexer available".to_string()),
                }
            }
        }
    }
    
    // Helper method to get an indexer address based on configuration
    async fn get_indexer_address(&mut self) -> Option<String> {
        if self.use_load_balancer {
            if let Some(lb_addr_str) = &self.load_balancer_address {
                // Convert string to Address
                let lb_addr = match Address::from_str(lb_addr_str) {
                    Ok(addr) => addr,
                    Err(e) => {
                        println!("Failed to parse load balancer address: {:?}", e);
                        return None;
                    }
                };
                
                // Get an available indexer from the load balancer
                match get_available_indexer_remote_rpc(&lb_addr).await {
                    SendResult::Success(Some(indexer)) => {
                        println!("Load balancer provided indexer: {}", indexer);
                        return Some(indexer);
                    },
                    SendResult::Success(None) => {
                        println!("Load balancer has no available indexers");
                    },
                    SendResult::Timeout => {
                        println!("Load balancer request timed out");
                    },
                    SendResult::Offline => {
                        println!("Load balancer is offline");
                    },
                    SendResult::DeserializationError(e) => {
                        println!("Load balancer response deserialization error: {}", e);
                    }
                }
                
                // If load balancer fails, fall back to direct indexer if configured
                if let Some(direct_indexer) = &self.direct_indexer_address {
                    println!("Falling back to direct indexer");
                    return Some(direct_indexer.clone());
                }
            }
        } else if let Some(direct_indexer) = &self.direct_indexer_address {
            // Use direct indexer
            return Some(direct_indexer.clone());
        }
        
        // No indexer available
        None
    }
}

// Result wrapper with error handling
#[derive(Serialize, Deserialize, Debug)]
struct IndexResult {
    success: bool,
    result_value: Option<Vec<String>>,
    error: Option<String>,
}

// Statistics structure
#[derive(Serialize, Deserialize, Debug)]
struct ClientStats {
    total_requests: u64,
    successful_requests: u64,
    failed_requests: u64,
    using_load_balancer: bool,
}
